# ü§ñ Guia de Integra√ß√£o LLM - Sistema de Sele√ß√£o de Provedor

## üìã Vis√£o Geral

A classe `QuestionUnderstandingAgent` foi refatorada para incluir um sistema de **sele√ß√£o expl√≠cita de provedor**, permitindo que o usu√°rio escolha qual motor de an√°lise utilizar:

1. **üß† OpenAI (GPT-4o)**: Para an√°lises complexas e robustas
2. **‚ö° Groq (Qwen3-32B)**: Para processamento r√°pido e eficiente
3. **üîç Regex**: Para an√°lises simples baseadas em padr√µes

**Importante**: N√£o h√° mais fallback autom√°tico - o provedor selecionado √© usado exclusivamente.

---

## üöÄ Configura√ß√£o

### Pr√©-requisitos

```bash
pip install langchain-openai langchain-groq
```

### Configura√ß√£o das API Keys

```bash
# Para OpenAI
export OPENAI_API_KEY=sua_api_key_openai

# Para Groq
export GROQ_API_KEY=sua_api_key_groq

# Opcional: especificar modelo Groq
export GROQ_MODEL=qwen/qwen3-32b
```

### Ou no c√≥digo Python:

```python
import os
os.environ['OPENAI_API_KEY'] = 'sua_api_key_openai'
os.environ['GROQ_API_KEY'] = 'sua_api_key_groq'
```

---

## üí° Como Funciona

### 1. Sele√ß√£o de Provedor

```python
from utils.llm_integration import reset_llm_integration

# Configurar provedor explicitamente
reset_llm_integration("openai")   # Para usar OpenAI GPT-4o
reset_llm_integration("groq")     # Para usar Groq Qwen3-32B
reset_llm_integration("regex")    # Para usar apenas padr√µes regex
```

### 2. Inicializa√ß√£o do Agente

```python
from agents.question_understanding import QuestionUnderstandingAgent

# O agente usa o provedor configurado globalmente
agent = QuestionUnderstandingAgent()

# Verificar provedor ativo
provider_mode = agent.llm_integration.provider_mode
print(f"Provedor ativo: {provider_mode}")
```

### 3. Processamento de Perguntas

```python
import pandas as pd

# Dados de exemplo
df = pd.DataFrame({
    'valor_total': [100, 200, 300],
    'produto': ['A', 'B', 'C']
})

dataframes = {'vendas.csv': df}

# Fazer pergunta - usa o provedor selecionado
result = agent.understand_question(
    "Qual √© a soma dos valores totais?", 
    dataframes
)

print(f"Provedor usado: {result['code_source']}")  # 'openai', 'groq' ou 'regex'
print(f"C√≥digo gerado: {result['generated_code']}")
```

---

## üîß Funcionalidades por Provedor

### üß† OpenAI (GPT-4o)

**Caracter√≠sticas:**
- üìä Interpreta√ß√£o mais sofisticada e robusta
- üéØ Melhor para an√°lises complexas e casos edge
- üîç Capacidade superior de entender contexto
- üí∞ Custo mais alto por requisi√ß√£o

**M√©todo `_generate_code_with_openai()`:**
```python
def _generate_code_with_openai(self, question: str, df_name: str, df: pd.DataFrame) -> Optional[str]
```

**Exemplo de uso:**
```python
# Para an√°lises complexas
reset_llm_integration("openai")
result = agent.understand_question(
    "Analise a correla√ß√£o entre vendas e sazonalidade, identificando padr√µes trimestrais",
    dataframes
)
# Resultado: c√≥digo pandas sofisticado com an√°lise estat√≠stica
```

### ‚ö° Groq (Qwen3-32B)

**Caracter√≠sticas:**
- üöÄ Processamento mais r√°pido
- ‚ö° Eficiente para an√°lises diretas
- üí∞ Custo menor por requisi√ß√£o
- üéØ Otimizado para respostas r√°pidas

**M√©todo `_generate_code_with_groq()`:**
```python
def _generate_code_with_groq(self, question: str, df_name: str, df: pd.DataFrame) -> Optional[str]
```

**Exemplo de uso:**
```python
# Para an√°lises r√°pidas
reset_llm_integration("groq")
result = agent.understand_question(
    "Top 10 produtos por volume de vendas",
    dataframes
)
# Resultado: c√≥digo pandas eficiente e direto
```

### üîç Regex (Padr√µes)

**Caracter√≠sticas:**
- üÜì Sempre dispon√≠vel, sem custos
- ‚ö° Resposta instant√¢nea
- üéØ Ideal para opera√ß√µes b√°sicas
- üîí N√£o depende de APIs externas

**M√©todo `_generate_code_with_regex()`:**
```python
def _generate_code_with_regex(self, question: str, df_name: str, df: pd.DataFrame) -> Optional[str]
```

**Exemplo de uso:**
```python
# Para opera√ß√µes simples
reset_llm_integration("regex")
result = agent.understand_question(
    "Soma da coluna valor_total",
    dataframes
)
# Resultado: c√≥digo pandas b√°sico e confi√°vel
```

---

## üìä Estrutura de Resposta

```python
{
    'original_question': 'Qual √© a soma dos valores?',
    'target_dataframe': 'vendas.csv',
    'generated_code': 'df = dataframes["vendas.csv"]\nresult = df["valor_total"].sum()',
    'confidence': 0.95,
    'explanation': 'C√≥digo gerado usando OpenAI GPT-4o',
    'code_source': 'openai',  # 'openai', 'groq' ou 'regex'
    'understood_intent': 'Soma de valores da coluna especificada',
    'provider_info': {
        'provider': 'openai',
        'model': 'gpt-4o',
        'response_time': 2.3
    }
}
```

---

## üéØ Exemplos Pr√°ticos por Provedor

### Exemplo 1: An√°lise Complexa (OpenAI)

```python
# Configurar OpenAI
reset_llm_integration("openai")
agent = QuestionUnderstandingAgent()

result = agent.understand_question(
    "Identifique outliers nas vendas e explique poss√≠veis causas baseadas na sazonalidade",
    dataframes
)

# Resultado esperado:
# code_source: 'openai'
# confidence: 0.95
# generated_code: c√≥digo sofisticado com an√°lise estat√≠stica
```

### Exemplo 2: An√°lise R√°pida (Groq)

```python
# Configurar Groq
reset_llm_integration("groq")
agent = QuestionUnderstandingAgent()

result = agent.understand_question(
    "M√©dia de vendas por categoria nos √∫ltimos 6 meses",
    dataframes
)

# Resultado esperado:
# code_source: 'groq'
# confidence: 0.90
# generated_code: c√≥digo eficiente e direto
```

### Exemplo 3: Opera√ß√£o B√°sica (Regex)

```python
# Configurar Regex
reset_llm_integration("regex")
agent = QuestionUnderstandingAgent()

result = agent.understand_question(
    "M√°ximo da coluna valor_total",
    dataframes
)

# Resultado esperado:
# code_source: 'regex'
# confidence: 1.0
# generated_code: df['valor_total'].max()
```

---

## üìà Vantagens da Nova Arquitetura

### üéØ **Controle Total do Usu√°rio**
- ‚úÖ Escolha expl√≠cita do provedor
- ‚úÖ Previsibilidade total dos resultados
- ‚úÖ Controle de custos direto
- ‚úÖ Transpar√™ncia completa

### üß† **OpenAI (GPT-4o)**
- ‚úÖ Interpreta√ß√£o mais robusta
- ‚úÖ Melhor para casos complexos
- ‚úÖ Suporte superior a edge cases
- ‚úÖ An√°lises mais profundas

### ‚ö° **Groq (Qwen3-32B)**
- ‚úÖ Velocidade superior
- ‚úÖ Efici√™ncia de processamento
- ‚úÖ Custo-benef√≠cio otimizado
- ‚úÖ Ideal para alto volume

### üîç **Regex**
- ‚úÖ Sempre dispon√≠vel
- ‚úÖ Zero depend√™ncias externas
- ‚úÖ Resposta instant√¢nea
- ‚úÖ Custo zero

---

## üîí Seguran√ßa

### Valida√ß√µes por Provedor

Todos os provedores aplicam as mesmas valida√ß√µes de seguran√ßa:

```python
# Elementos obrigat√≥rios
required_elements = [
    f"dataframes['{df_name}']",  # Carregamento do DataFrame
    "result =",                   # Atribui√ß√£o do resultado
]

# Padr√µes perigosos bloqueados
dangerous_patterns = [
    'import os', 'import sys', 'exec(', 'eval(', 
    'open(', '__import__', 'subprocess'
]
```

### Isolamento por Provedor

Cada provedor opera de forma isolada:
- **OpenAI**: Valida√ß√£o adicional de prompts
- **Groq**: Otimiza√ß√£o de performance
- **Regex**: Valida√ß√£o de padr√µes conhecidos

---

## üìä Monitoramento e Logs

### Logs por Provedor

```python
# Logs de sele√ß√£o
logger.info("Provider selected: openai")
logger.info("Provider switched from groq to regex")

# Logs de processamento
logger.debug("OpenAI Prompt enviado: ...")
logger.debug("Groq Response recebida: ...")
logger.info("‚úÖ Usando c√≥digo gerado por OpenAI")
logger.info("‚ö° Usando c√≥digo gerado por Groq")
logger.info("üîç Usando padr√£o regex identificado")

# Logs de valida√ß√£o
logger.info("‚úÖ C√≥digo OpenAI validado com sucesso")
logger.warning("‚ùå C√≥digo Groq inv√°lido para esta pergunta")
```

### M√©tricas por Provedor

```python
# Acessar estat√≠sticas de uso
from utils.llm_integration import llm_integration

stats = llm_integration.get_usage_stats()
print(f"Provedor ativo: {stats['primary_provider']}")
print(f"Modelo usado: {stats['model']}")
print(f"Modo selecionado: {stats['selected_mode']}")
```

---

## üéØ Casos de Uso por Provedor

### 1. OpenAI - An√°lises Complexas
- "Analise tend√™ncias sazonais e sugira estrat√©gias de vendas"
- "Identifique correla√ß√µes entre m√∫ltiplas vari√°veis"
- "Explique anomalias nos dados com contexto de neg√≥cio"

### 2. Groq - An√°lises R√°pidas
- "Top 20 produtos mais vendidos por categoria"
- "Resumo de performance mensal por vendedor"
- "Distribui√ß√£o de clientes por faixa et√°ria"

### 3. Regex - Opera√ß√µes B√°sicas
- "Soma da coluna receita"
- "M√©dia de idade dos clientes"
- "Contagem de registros por status"

---

## üöÄ Configura√ß√£o Avan√ßada

### Personaliza√ß√£o por Provedor

```python
from utils.llm_integration import LLMIntegration

# Configura√ß√£o customizada para OpenAI
openai_integration = LLMIntegration(provider="openai")
if openai_integration.client:
    openai_integration.client.temperature = 0.0  # Mais determin√≠stico
    openai_integration.client.max_tokens = 1000   # Respostas mais longas

# Configura√ß√£o customizada para Groq
groq_integration = LLMIntegration(provider="groq")
if groq_integration.client:
    groq_integration.client.temperature = 0.1   # Levemente criativo
    groq_integration.client.max_tokens = 500    # Respostas concisas
```

### Sele√ß√£o Din√¢mica por Tipo de Pergunta

```python
def select_optimal_provider(question: str) -> str:
    """Seleciona o provedor ideal baseado no tipo de pergunta"""
    
    # Palavras-chave para an√°lises complexas (OpenAI)
    complex_keywords = ['correla√ß√£o', 'tend√™ncia', 'an√°lise', 'explique', 'sugira']
    
    # Palavras-chave para an√°lises r√°pidas (Groq)
    fast_keywords = ['top', 'ranking', 'resumo', 'm√©dia', 'total']
    
    # Palavras-chave para opera√ß√µes b√°sicas (Regex)
    basic_keywords = ['soma', 'm√°ximo', 'm√≠nimo', 'contagem']
    
    question_lower = question.lower()
    
    if any(keyword in question_lower for keyword in complex_keywords):
        return "openai"
    elif any(keyword in question_lower for keyword in fast_keywords):
        return "groq"
    elif any(keyword in question_lower for keyword in basic_keywords):
        return "regex"
    else:
        return "groq"  # Default para equil√≠brio velocidade/capacidade

# Uso autom√°tico
optimal_provider = select_optimal_provider(user_question)
reset_llm_integration(optimal_provider)
```

---

## üîÑ Migra√ß√£o da Vers√£o Anterior

### Principais Mudan√ßas

1. **Elimina√ß√£o do Fallback Autom√°tico**
   ```python
   # Antes (v2.0): fallback autom√°tico
   # O sistema tentava LLM ‚Üí Regex automaticamente
   
   # Agora (v3.1): sele√ß√£o expl√≠cita
   reset_llm_integration("openai")  # Usa apenas OpenAI
   reset_llm_integration("groq")    # Usa apenas Groq
   reset_llm_integration("regex")   # Usa apenas Regex
   ```

2. **Nova Interface de Sele√ß√£o**
   ```python
   # Antes: sistema decidia automaticamente
   agent = QuestionUnderstandingAgent()
   
   # Agora: usu√°rio escolhe explicitamente
   reset_llm_integration("groq")
   agent = QuestionUnderstandingAgent()
   ```

3. **Controle de Custos**
   ```python
   # Agora voc√™ controla exatamente quando usar APIs pagas
   if budget_available and complex_analysis_needed:
       reset_llm_integration("openai")
   elif speed_required:
       reset_llm_integration("groq")
   else:
       reset_llm_integration("regex")  # Sem custos
   ```

---

## üéâ Conclus√£o

A nova arquitetura de **sele√ß√£o expl√≠cita de provedor** oferece:

- üéØ **Controle Total**: Usu√°rio decide qual provedor usar
- üß† **OpenAI (GPT-4o)**: Para an√°lises complexas e robustas
- ‚ö° **Groq (Qwen3-32B)**: Para processamento r√°pido e eficiente
- üîç **Regex**: Para disponibilidade garantida sem custos
- üîí **Seguran√ßa**: Valida√ß√£o robusta em todos os provedores
- üìä **Transpar√™ncia**: Rastreabilidade completa do processamento
- üí∞ **Controle de Custos**: Uso intencional de APIs pagas

O sistema est√° pronto para produ√ß√£o e oferece flexibilidade total para diferentes cen√°rios de uso!

## üîß **Configura√ß√£o de M√∫ltiplos Provedores**

O CSV QA Agent agora oferece **sele√ß√£o expl√≠cita de provedor**, permitindo que o usu√°rio escolha qual motor de an√°lise utilizar para cada sess√£o:

### üéØ **Provedores Dispon√≠veis**

1. **üß† OpenAI (GPT-4o)**
   - **Modelo**: `gpt-4o`
   - **Caracter√≠sticas**: Alta precis√£o, an√°lises complexas, interpreta√ß√£o robusta
   - **Ideal para**: Casos complexos, an√°lises estrat√©gicas, edge cases

2. **‚ö° Groq (Qwen3-32B)**
   - **Modelo**: `qwen/qwen3-32b`
   - **Caracter√≠sticas**: Alta velocidade, processamento eficiente, custo otimizado
   - **Ideal para**: An√°lises r√°pidas, alto volume, opera√ß√µes diretas

3. **üîç Regex (Padr√µes)**
   - **Modelo**: Sistema baseado em padr√µes pr√©-definidos
   - **Caracter√≠sticas**: Sempre dispon√≠vel, sem custos, resposta instant√¢nea
   - **Ideal para**: Opera√ß√µes b√°sicas, ambiente sem internet, controle total de custos

### üö´ **Elimina√ß√£o do Fallback Autom√°tico**

**Mudan√ßa Importante**: O sistema n√£o possui mais fallback autom√°tico entre provedores. Cada provedor opera de forma independente conforme a sele√ß√£o do usu√°rio.

**Benef√≠cios:**
- **Previsibilidade**: Resultados consistentes com o provedor escolhido
- **Controle de Custos**: Evita uso n√£o intencional de APIs pagas
- **Transpar√™ncia**: Clareza total sobre qual provedor est√° processando
- **Performance**: Otimiza√ß√£o espec√≠fica para cada caso de uso

### ‚öôÔ∏è **Como Configurar**

Para habilitar os provedores desejados:

```bash
# OpenAI (para an√°lises robustas)
export OPENAI_API_KEY=sk-sua_chave_openai

# Groq (para an√°lises r√°pidas)
export GROQ_API_KEY=gsk-sua_chave_groq

# Opcional: especificar modelo Groq diferente
export GROQ_MODEL=qwen/qwen3-32b

# Regex est√° sempre dispon√≠vel (n√£o requer configura√ß√£o)
```

### üîç **Interface de Sele√ß√£o**

Na aplica√ß√£o Streamlit, o usu√°rio:

1. **Visualiza** os provedores dispon√≠veis na sidebar
2. **Seleciona** o provedor desejado via interface radio button
3. **Confirma** a mudan√ßa com feedback visual imediato
4. **Monitora** o status do provedor ativo em tempo real

### üìä **Monitoramento**

O sistema registra nos logs:
- Qual provedor foi selecionado pelo usu√°rio
- Tempo de resposta por provedor
- Taxa de sucesso por tipo de provedor
- Custos de API (quando aplic√°vel)

Isso permite an√°lise detalhada de performance e otimiza√ß√£o de uso baseada em necessidades espec√≠ficas. 